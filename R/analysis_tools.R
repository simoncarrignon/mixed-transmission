

#using a the result of a simulation
#return the type of comu (0,1,2,3) 
getCommuType <- function(exp){
    comusize=exp$comusize
    ncomu=length(comusize[[length(comusize)]])
    sapply(1:ncomu,function(com){
               st=min(which(!is.na(sapply(comusize,function(size)size[com]))))
               sum(exp$traitpercomu[[st]][com,paste0("a",1:3)]/comusize[[st]][com])
    })
}

#using a the result of a simulation
#return the type of comu (0,1,2,3) 
getCountBySexAndCommu <- function(population,pathways,type=NULL){
    traitsid=paste0("t",seq_along(pathways$s))
    freqcom=c()
    wholecomus=sort(unique(population[,"community"])) 
    for(s in c(0,1)){
        single.bias=traitsid[pathways$s == s]
        singlesex=population[population[,"sex"]==s,]
        singlesex.comus=factor(singlesex[,"community"],levels=wholecomus)
        freqcom=cbind(freqcom,stats::xtabs(singlesex[,single.bias] ~ singlesex.comus)/as.numeric(table(singlesex.comus)))
    }       
    single.bias=traitsid[pathways$s == 0.5]
    freqcom=cbind(freqcom,stats::xtabs(population[,single.bias] ~ population[,"community"])/as.numeric(table(population[,"community"])))
    freqcom[,traitsid]
}

#diffexp allo to keep separated simulation within the same folder but that have been generated by different parameters
extractResults <- function(expname,pathways=pathways,traitsel=NULL,type=F,diffexp=F,params=NULL,ntype=2,log=T){
    if(!is.null(params)){
        allsingle.exp  <-  file.path(expname,paste0("singlesimu_s_",params,".RDS"))
    }
    else{
        allsingle.exp <- list.files(expname,pattern = "si.*\\.RDS",full.names = TRUE)
    }
    alltraitComu=lapply(allsingle.exp,function(expfname){
                            if(log)print(expfname)
                            if(!file.exists(expfname))return(NULL)
                            one=readRDS(expfname)
                            population=NULL
                            end=getSimFull(one)
                            if(is.null(one$popwhenfull))
                                population=one$population
                            else
                                population=one$popwhenfull
                            counts=getCountBySexAndCommu(population,pathways)
                            if(type){
                                ctypes=apply(one$traitpercomu[[end]][,paste0("a",1:3)]/one$comusize[[end]],1,sum)
                                ctypes=ctypes[!is.nan(ctypes)]
                                if(ntype==3){
                                    ctypes[ctypes %in% c(1,2)]=-1
                                    ctypes[ctypes==0]=1
                                    ctypes[ctypes==3]=2
                                    ctypes[ctypes==-1]=3
                                    ctypes=factor(ctypes,levels=c(1,2,3))
                                }
                                else{
                                    ctypes[ctypes %in% c(1,2,3)]=2
                                    ctypes[ctypes==0]=1
                                    ctypes=factor(ctypes,levels=c(1,2))
                                }
                                
                                counts=lapply(levels(ctypes),function(ct)counts[ctypes==ct,,drop=F])
                            }
                            ##still some few cases where communities have NA because there is only people from one sex or another, in which case we now remove them
                            if(type)lapply(counts,function(nc)nc[!apply(nc,1,function(i)any(is.nan(i))),,drop=F])
                            else counts[!apply(counts,1,function(i)any(is.nan(i))),,drop=F]
})
    if(type)return(lapply(1:ntype,function(ctype)lapply(traitsel,function(ti)unlist(lapply(alltraitComu,function(singex)if(nrow(singex[[ctype]])>0)singex[[ctype]][,ti])))))
    if(!is.null(params)) return(lapply(traitsel,function(ti)unlist(lapply(alltraitComu,function(singex)singex[,ti]))))
    return(lapply(traitsel,function(ti) unlist(lapply(alltraitComu,function(singex)singex[,ti]))))
}


#' Calculate Density with Adjusted Bounds and Normalize
#'
#' This function calculates the density of given traits, adjusts the bounds of
#' the density calculation, and normalizes the density values.
#'
#' @param traits Numeric vector representing the traits to calculate the density of.
#' @param bw Bandwidth parameter for the density calculation; controls the smoothness.
#' @return A matrix with two columns. The first column contains the x-values, and the
#' second column contains the normalized y-values of the density.
#' @examples
#' traits <- c(rnorm(100, 0.5, 0.1), rnorm(100, 0.7, 0.1))
#' densResult <- getDensities(traits)
#' plot(densResult[,1], densResult[,2], type = 'l')
#' @importFrom stats  density 
#' @export
getDensities <- function(traits,bw=0.05){
    if(is.null(traits))return(NULL)
    traits.dens=density(traits,na.rm=T,from=0,to=1,bw=bw)
    y=c(0,traits.dens$y,0)
    x=c(0,traits.dens$x,1)
    return(cbind(x,y/max(y)))
}

getSimFull <- function(simres){
    if(any(lengths(simres$comusize)==100))
        min(which(lengths(simres$comusize)==100))
    else
        length(simres$popsize)
}
extractComSiz <- function(expname,pathways=pathways,traitsel=NULL,type=F,diffexp=F,params=NULL,ntype=2,log=T){
        allsingle.exp <- list.files(expname,pattern = "si.*\\.RDS",full.names = TRUE)
    alltraitComu=lapply(allsingle.exp,function(expfname){
                            if(log)print(expfname)
                            if(!file.exists(expfname))return(NULL)
                            one=readRDS(expfname)
    one$finalcomus$size
})
    unlist(alltraitComu)
}
